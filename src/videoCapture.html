<html>

<head>
<title>MATA65 - Computação Gráfica</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">

<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aVertexTexture;
		
	varying vec2 vTextureCoord;
	
	void main(void) {
		gl_Position = vec4(aVertexPosition, 1.0);
		vTextureCoord = aVertexTexture;
	}
</script>

<script id="shader-fs" type="x-shader/x-fragment">
	precision mediump float;
		
	uniform sampler2D uSampler;
	uniform float lightness;
	
	varying vec2 vTextureCoord;
		
	void main(void) {	
		vec4 c = texture2D(uSampler, vTextureCoord);
		
		/*
		* 	RGB values range from 0 to 255.
		* 	Hue ranges from 0° to 360°.
		*	Saturation ranges from 0 to 1.
		*	Lightness ranges from 0 to 1.
		*/
		
		// http://www.had2know.com/technology/hsl-rgb-color-converter.html
		// mapeia de [0..1] para [0..255]
		float r = 255.0 * c.r;
		float g = 255.0 * c.g;
		float b = 255.0 * c.b;
		
		/********* RGB to HSL *********/
		//max
		float max = r;
		if(g > max){
			max = g;
		}
		if(b > max){
			max = b;
		}

		// min
		float min = r;
		if(g < min){
			min = g;
		}
		if(b < min){
			min = b;
		}
		
		float d = (max - min)/255.0;
		
		// Lightness
		float L = (max + min)/510.0;
		
		// Saturation
		float S;
		if(L > 0.0){
			S = d/(1.0 - abs((2.0*L)-1.0));
		}
		if(L == 0.0){
			S = 0.0;
		}
		
		// Hue
		float H;
		if(g >= b){
			H = 1.0 / cos( (r - (g/2.0) - (b/2.0)) / sqrt(pow(r,2.0) + pow(g,2.0) + pow(b,2.0) - (r*g) - (r*b) - (g*b)) );
		}else if(b > g){
			H = 360.0 - (1.0 / cos( (r - (g/2.0) - (b/2.0)) / sqrt(pow(r,2.0) + pow(g,2.0) + pow(b,2.0) - (r*g) - (r*b) - (g*b)) ));
		}
		
		// altera o brilho
		L += lightness;
		
		/************************ HSL to RGB *********************/
		
		d = S * (1.0 - abs((2.0*L)-1.0));
		float m = 255.0 * (L - (d/2.0));
		
		// x = d[1 - |(H/60)mod_2 - 1|]
		float x = d * (1.0 - abs(mod((H/60.0),2.0) - 1.0));
		
		if(H>=0.0 && H < 60.0){
			r = (255.0 * d) + m;
			g = (255.0 * x) + m;
			b = m;
		}
		
		if(H>=60.0 && H < 120.0){
			r = (255.0 * x) + m;
			g = (255.0 * d) + m;
			b = m;
		}
		
		if(H>=120.0 && H < 180.0){
			r = m;
			g = (255.0 * d) + m;
			b = (255.0 * x) + m;
		}
		
		if(H>=180.0 && H < 240.0){
			r = m;
			g = (255.0 * x) + m;
			b = (255.0 * d) + m;
		}
		
		if(H>=240.0 && H < 300.0){
			r = (255.0 * x) + m;
			g = m;
			b = (255.0 * d) + m;
		}
		
		if(H>=300.0 && H < 360.0){
			r = (255.0 * d) + m;
			g = m;
			b = (255.0 * x) + m;
		}
		
		r = r/255.0;
		g = g/255.0;
		b = b/255.0;
		
		// aplica a cor convertida
		gl_FragColor = vec4(r, g, b, 1.0);
	}
		
		
</script>

<script type="text/javascript" src="../lib/webgl-utils.js"></script>
<script type="text/javascript" src="../lib/shaders.js"></script>
<script type="text/javascript" src="videoCapture.js"></script>

</head>

<body onload="webGLStart();">
    <h1>Trabalho</h1><br />
    <p>Captura e manipulação de video em WebGL.</p>
	Lightness
	0<input type="range" id="lightness" min="0" max="1" step="0.1" value="0">1.0
    <br/>
    <div id="output"> </div>
    <br/>
	<canvas id="videoGL" width="320" height="240" style="visibility: visible;"></canvas>
	<video id="monitor" autoplay width="320" height="240" style="visibility: hidden;"></video>
	<canvas id="videoImage" width="256" height="256" style="visibility: hidden;"></canvas>
</body>

</html>